FILSON PORTLAND DATA PIPELINE - PROJECT TREE STRUCTURE

This document shows the complete folder and file structure for all components 
involved in the data pipeline, organized by their role in the system.

====================================================================================
📂 ROOT PROJECT STRUCTURE
====================================================================================

retail-ops-app/
├── 📋 PROJECT CONFIG FILES
│   ├── package.json                    # Dependencies & scripts (Papa Parse, Day.js, etc.)
│   ├── package-lock.json              # Dependency lockfile
│   ├── vite.config.js                 # Build config with path aliases (@, @lib, @data)
│   ├── jsconfig.json                  # JavaScript/React configuration
│   ├── tailwind.config.js             # CSS framework config
│   └── postcss.config.js              # CSS processing config
│
├── 🏠 APPLICATION ENTRY POINTS
│   ├── index.html                     # HTML entry point
│   └── src/
│       ├── main.jsx                   # React application bootstrap
│       ├── App.jsx                    # Main app with tab navigation → Analytics
│       └── index.css                  # Global styles
│
├── 📚 SHARED LIBRARIES
│   └── lib/
│       └── dataPaths.js               # 🔗 Universal JSON loader (browser/Node.js)
│
├── 🗂️ STATIC DATA SERVING
│   └── public/
│       └── data/                      # Static file serving root
│           ├── registry/              # Data discovery manifests
│           │   └── index.json         # 🔗 Master data registry
│           ├── newstore/              # NewStore data source
│           │   ├── orders/            # Order data hierarchy
│           │   │   ├── index.json     # 🔗 Orders manifest
│           │   │   ├── 2023/          # Year-based organization
│           │   │   │   ├── 2023-01/
│           │   │   │   │   └── 2023-01_orders_in_store.csv  # 🔗 Monthly order data
│           │   │   │   ├── 2023-02/
│           │   │   │   │   └── 2023-02_orders_in_store.csv
│           │   │   │   └── ... (monthly files)
│           │   │   ├── 2024/
│           │   │   │   └── ... (similar monthly structure)
│           │   │   └── 2025/
│           │   │       └── ... (similar monthly structure)
│           │   └── catalog/           # Product catalog data
│           │       └── storefront-catalog-en-us.csv  # 🔗 Product data
│           ├── kepler/                # Additional data sources (future)
│           └── schemas/               # Data validation schemas
│               └── orders_in_store.schema.v1.json  # 🔗 Order data schema
│
├── 🧠 CORE PIPELINE INFRASTRUCTURE
│   └── src/core/
│       ├── 🌐 HTTP & NETWORKING
│       │   └── io/
│       │       └── HttpStaticProvider.js    # 🔗 HTTP client for static files
│       │
│       ├── 🛤️ PATH RESOLUTION
│       │   └── paths/
│       │       ├── ManifestClient.js        # 🔗 Data registry client
│       │       └── PathResolver.js          # 🔗 URL template resolution
│       │
│       ├── ⚙️ CONFIGURATION
│       │   └── config/
│       │       └── dataSources.js           # 🔗 Data source configurations
│       │
│       ├── 📊 DATA SCHEMAS
│       │   └── schemas/
│       │       └── ordersInStore.schema.v1.json  # 🔗 Order schema definition
│       │
│       └── 🔧 DATA UTILITIES
│           └── utils/
│               └── ordersNormalizer.js      # 🔗 Advanced timezone & data normalization
│
├── 🔬 ANALYTICS FEATURE MODULE
│   └── src/features/analytics/
│       ├── 🗄️ DATA ACCESS LAYER
│       │   └── repositories/
│       │       └── OrdersRepository.js      # 🔗 Main data access with CSV parsing
│       │
│       ├── 🎯 BUSINESS LOGIC LAYER  
│       │   └── services/
│       │       └── AnalyticsService.js      # 🔗 Pipeline orchestration
│       │
│       ├── 🔄 DATA TRANSFORMATION ADAPTERS
│       │   └── adapters/
│       │       ├── time/
│       │       │   └── timeAdapter.js       # 🔗 Date range filtering
│       │       ├── productAdapter.js        # 🔗 Product filtering
│       │       └── metricAdapter.js         # 🔗 Metric calculations
│       │
│       ├── 📋 DATA CONTRACTS (DTOs)
│       │   └── dtos/
│       │       ├── QueryDTO.js              # 🔗 Query normalization
│       │       ├── TableDTO.js              # 🔗 Table structure definition
│       │       └── ChartDTO.js              # 🔗 Chart structure definition
│       │
│       ├── 🏭 DATA TRANSFORMATION (FEEDERS)
│       │   └── feeders/
│       │       ├── tableFeeder.js           # 🔗 Raw data → Table format
│       │       └── chartFeeder.js           # 🔗 Raw data → Chart format
│       │
│       ├── ⚛️ REACT INTEGRATION
│       │   └── hooks/
│       │       └── useAnalyticsQuery.js     # 🔗 Main React hook orchestrator
│       │
│       ├── 🎨 UI COMPONENTS
│       │   └── components/
│       │       ├── StatusDisplay.jsx        # 🔗 Query status & error display
│       │       ├── charts/
│       │       │   └── Chart.jsx            # 🔗 Data visualization component
│       │       ├── tables/
│       │       │   └── Table.jsx            # 🔗 Advanced data table with scrolling
│       │       ├── panels/
│       │       │   ├── Panel.jsx            # 🔗 Filter panel shell
│       │       │   └── tabs/
│       │       │       ├── index.js         # Tab registry
│       │       │       ├── time/
│       │       │       │   ├── Time.jsx     # Time filter UI
│       │       │       │   └── Calendar.jsx # Date picker
│       │       │       ├── product/
│       │       │       │   └── Product.jsx  # Product filter UI
│       │       │       ├── metric/
│       │       │       │   └── Metric.jsx   # Metric filter UI
│       │       │       ├── element/
│       │       │       │   └── Element.jsx  # Element filter UI
│       │       │       └── trend/
│       │       │           └── Trend.jsx    # Trend filter UI
│       │       └── menus/
│       │           ├── Menu.jsx             # 🔗 Dropdown menu system
│       │           └── Menu.css             # Menu styling
│       │
│       └── 📊 ANALYTICS REGISTRIES
│           └── registry/
│               ├── tableRegistry.js         # Table configuration registry
│               ├── kpiRegistry.js          # KPI definitions
│               └── kpis/
│                   ├── index.js            # KPI index
│                   └── top_performers.js   # 🔗 Top performers KPI logic
│
├── 📱 PAGE INTEGRATION
│   └── src/pages/
│       ├── Analytics.jsx                   # 🔗 Main analytics page (pipeline consumer)
│       ├── Store.jsx                       # Store dashboard page
│       ├── Catalog.jsx                     # Product catalog page
│       ├── Zones.jsx                       # Zone management page
│       └── Assistant.jsx                   # AI assistant page
│
├── 🔧 OTHER FEATURE MODULES
│   └── src/features/
│       ├── storeDashboard/                 # Store dashboard components
│       │   └── components/
│       │       ├── OverviewCard.jsx
│       │       └── VisualStoreTrends.jsx   # 🔗 Uses some pipeline concepts
│       ├── catalog/                        # Product catalog feature (separate pipeline)
│       ├── common/                         # Shared components
│       └── Inventory/                      # Inventory management
│
├── 🧪 TESTING & VALIDATION
│   └── scripts/
│       └── smoke/
│           ├── validate_orders_in_store_month.mjs  # 🔗 Data validation script
│           └── print-architecture.mjs      # Architecture documentation script
│
└── 📚 DOCUMENTATION
    ├── project-code-summary.txt           # High-level code summary
    ├── data-pipeline-source-code-roadmap.txt  # Complete source code reference  
    ├── data-pipeline-project-tree.txt     # This file - structure overview
    └── docs/                              # Additional documentation
        └── dev-notes/                     # Development notes
            ├── README_MASTER.md
            ├── TEMPLATE.md
            └── 2025-08/                   # Monthly development logs

FILSON PORTLAND RETAIL OPERATIONS APP - CODE SUMMARY & DATA PIPELINE ARCHITECTURE

====================================================================================
PROJECT OVERVIEW
====================================================================================

This is a React-based retail operations application called "Filson Portland" built with Vite, 
featuring a mobile-first design (390px x 844px viewport). The app provides multiple 
specialized views for retail store management including analytics, store dashboards, 
product catalogs, and an AI assistant interface.

Technology Stack:
- React 18 with JSX
- Vite build system
- TailwindCSS for styling
- Papa Parse for CSV processing
- Chart.js & Recharts for visualization
- Day.js for date/time handling
- Various UI libraries (Heroicons, Tabler Icons, Framer Motion)

====================================================================================
APPLICATION ARCHITECTURE
====================================================================================

MAIN ENTRY POINT (App.jsx):
- Single-page application with tab-based navigation
- Five main sections: Store, Catalog, Zones, Analytics, Assistant
- Mobile-optimized UI with fixed header (60px) and bottom tab bar (56px)
- Main content area is scrollable (728px height)

NAVIGATION STRUCTURE:
┌─ Store Dashboard (Primary KPIs, trends, overview)
├─ Catalog (Product search and browsing)
├─ Zones (Placeholder for future zone management)
├─ Analytics (Advanced reporting and data analysis)
└─ Assistant (AI-powered retail assistance)

====================================================================================
DATA PIPELINE ARCHITECTURE
====================================================================================

The application features a sophisticated multi-layered data pipeline designed for 
processing retail order data with temporal and geographical considerations:

LAYER 1: CORE INFRASTRUCTURE
----------------------------

1. HTTP PROVIDER (HttpStaticProvider.js):
   - Handles all HTTP requests with cache control
   - Supports both JSON and text responses
   - Error handling with detailed status codes

2. MANIFEST CLIENT (ManifestClient.js):
   - Manages data registry/index files
   - Provides month listing capabilities
   - Caches manifest data for performance

3. PATH RESOLVER (PathResolver.js):
   - Resolves file paths using template patterns
   - Supports multiple candidate URLs for data files
   - Handles year/month directory structures

4. DATA SOURCES CONFIG (dataSources.js):
   - Centralized configuration for data endpoints
   - Defines URL patterns for orders data
   - Structure: /data/newstore/orders/{yyyy}/{yyyy-mm}/{yyyy-mm}_orders_in_store.csv

LAYER 2: DATA NORMALIZATION
---------------------------

ORDER NORMALIZER (ordersNormalizer.js):
- Advanced timezone conversion system
- Multi-strategy date parsing (5 different approaches)
- Timezone mapping (EDT/EST -> America/New_York, etc.)
- Source timezone: America/New_York (Eastern)
- Target timezone: America/Los_Angeles (Pacific)
- Numerical data cleaning (removes $, commas)
- Robust error handling with fallbacks

Key Normalization Features:
- Handles multiple date formats: "YYYY-MM-DD h:mmA", "YYYY-MM-DD hh:mmA"
- Timezone abbreviation mapping to IANA standards
- Financial data sanitization
- Preserves original data while adding normalized fields

LAYER 3: REPOSITORY PATTERN
---------------------------

ORDERS REPOSITORY (OrdersRepository.js):
- Implements data access layer for order information
- Fetches data by month ranges using manifest
- Parallel loading of multiple CSV files
- Comprehensive error handling and missing data tracking
- Returns structured result: { rows, present, missing }

Data Flow:
1. Queries manifest for available months
2. Filters months by date range
3. Attempts to load each month's CSV file
4. Normalizes all successful rows
5. Tracks missing/failed months for reporting

LAYER 4: BUSINESS LOGIC SERVICE
-------------------------------

ANALYTICS SERVICE (AnalyticsService.js):
- Orchestrates repository and adapter layers
- Applies filtering and transformation logic
- Handles time, product, and metric scoping

ADAPTER SYSTEM:
- timeAdapter.js: Date range filtering
- productAdapter.js: Product-based filtering  
- metricAdapter.js: Metric calculations and aggregations

LAYER 5: DATA TRANSFORMATION
----------------------------

FEEDERS:
- tableFeeder.js: Converts raw data to table format
- chartFeeder.js: Prepares data for visualization

DTOs (Data Transfer Objects):
- QueryDTO.js: Query parameter normalization
- TableDTO.js: Table structure definitions
- ChartDTO.js: Chart data formatting

====================================================================================
FEATURE MODULES
====================================================================================

ANALYTICS MODULE:
- Complex query system with time, product, and metric filters
- Real-time data processing and visualization
- Tabbed interface for different filter types
- Chart and table display components
- Status tracking for data availability

Components:
- Panel.jsx: Filter interface shell
- Menu.jsx: Dropdown panels for filters
- Chart.jsx: Data visualization
- Table.jsx: Tabular data display
- StatusDisplay.jsx: Query status and missing data alerts

Query System:
- Time-based filtering (date ranges)
- Product filtering (by name, category, etc.)
- Metric calculations (revenue, quantities, etc.)
- Real-time updates with loading states

STORE DASHBOARD:
- Overview cards with key performance indicators
- Visual trend analysis
- Store-specific metrics and insights

CATALOG MODULE:
- CSV-based product catalog loading
- Real-time search functionality (title, brand, product ID)
- Image handling with fallbacks
- JSON-in-CSV parsing for complex attributes
- Responsive grid layout for mobile viewing

Data Processing:
- Papa Parse for CSV processing
- JSON attribute parsing (images, identifiers)
- Primary image selection logic
- Currency formatting with Intl.NumberFormat

====================================================================================
DATA FLOW SUMMARY
====================================================================================

1. USER INTERACTION
   ↓
2. REACT HOOKS (useAnalyticsQuery)
   ↓
3. ANALYTICS SERVICE (business logic)
   ↓
4. ORDERS REPOSITORY (data access)
   ↓
5. CORE INFRASTRUCTURE (HTTP, paths, manifest)
   ↓
6. CSV FILES (static data storage)
   ↓
7. NORMALIZATION (timezone, currency, dates)
   ↓
8. ADAPTERS (filtering, scoping)
   ↓
9. FEEDERS (data transformation)
   ↓
10. UI COMPONENTS (visualization)

====================================================================================
KEY ARCHITECTURAL DECISIONS
====================================================================================

1. STATIC FILE ARCHITECTURE:
   - Uses static CSV files served from /public/data/
   - No backend database, all processing client-side
   - Manifest-driven data discovery

2. TIMEZONE HANDLING:
   - Sophisticated multi-strategy parsing
   - Conversion from Eastern to Pacific time
   - Preserves original timestamps

3. ERROR RESILIENCE:
   - Graceful handling of missing data files
   - Multiple parsing strategies for dates
   - Detailed error reporting and fallbacks

4. PERFORMANCE CONSIDERATIONS:
   - Caching of manifest data
   - Lazy loading of CSV files
   - Efficient React re-rendering patterns

5. MODULAR DESIGN:
   - Clear separation of concerns
   - Repository pattern for data access
   - Adapter pattern for data transformation
   - DTO pattern for type safety

====================================================================================
DEVELOPMENT & DEBUGGING
====================================================================================

The application includes extensive console logging for debugging:
- Data loading progress
- Timezone conversion details
- Missing file tracking
- Query execution flow

Build Scripts:
- npm run dev: Development server
- npm run build: Production build
- npm run smoke:orders: Data validation script

The codebase follows React best practices with hooks, proper state management,
and component composition patterns. The data pipeline is designed to handle
real-world retail data challenges including timezone complexity, missing files,
and varying data formats.

====================================================================================

====================================================================================
🔗 PIPELINE DATA FLOW PATHWAYS
====================================================================================

PRIMARY DATA FLOW PATHWAY:
==========================

1. USER INTERFACE
   src/pages/Analytics.jsx 
   └── 🔄 Query State Management

2. REACT INTEGRATION  
   src/features/analytics/hooks/useAnalyticsQuery.js
   └── 🔄 Pipeline Orchestration

3. BUSINESS LOGIC
   src/features/analytics/services/AnalyticsService.js
   └── 🔄 Service Coordination

4. DATA ACCESS
   src/features/analytics/repositories/OrdersRepository.js
   └── 🔄 CSV Loading & Parsing

5. CORE INFRASTRUCTURE
   ├── src/core/paths/ManifestClient.js         (Data Discovery)
   ├── src/core/paths/PathResolver.js           (URL Resolution)  
   ├── src/core/io/HttpStaticProvider.js        (HTTP Requests)
   └── src/core/config/dataSources.js           (Configuration)

6. STATIC DATA FILES
   public/data/newstore/orders/[YYYY]/[YYYY-MM]/[YYYY-MM]_orders_in_store.csv
   └── 🔄 Raw CSV Data

7. DATA NORMALIZATION
   src/core/utils/ordersNormalizer.js
   └── 🔄 Timezone & Format Conversion

8. DATA FILTERING
   ├── src/features/analytics/adapters/time/timeAdapter.js      (Time Filtering)
   ├── src/features/analytics/adapters/productAdapter.js       (Product Filtering)
   └── src/features/analytics/adapters/metricAdapter.js        (Metric Processing)

9. UI TRANSFORMATION
   ├── src/features/analytics/feeders/tableFeeder.js           (Table Format)
   └── src/features/analytics/feeders/chartFeeder.js           (Chart Format)

10. USER INTERFACE RENDERING
    ├── src/features/analytics/components/tables/Table.jsx     (Data Display)
    ├── src/features/analytics/components/StatusDisplay.jsx    (Status Info)
    └── src/features/analytics/components/charts/Chart.jsx     (Visualization)

CONFIGURATION PATHWAY:
=====================

Application Config → Core Config → Runtime Config
├── vite.config.js                    # Path aliases & build setup
├── src/core/config/dataSources.js    # Data source definitions  
├── public/data/registry/index.json   # Data registry manifest
└── public/data/newstore/orders/index.json  # Orders manifest

SCHEMA VALIDATION PATHWAY:  
=========================

Data Schema → Normalization → Validation
├── src/core/schemas/ordersInStore.schema.v1.json  # JSON Schema definition
├── src/core/utils/ordersNormalizer.js              # Data transformation  
└── scripts/smoke/validate_orders_in_store_month.mjs # Validation testing

ERROR HANDLING PATHWAY:
======================

Component Errors → Hook Errors → Service Errors → Repository Errors → Core Errors
├── UI Components (try/catch, error boundaries)
├── useAnalyticsQuery (error state management)  
├── AnalyticsService (business logic errors)
├── OrdersRepository (data access errors)
└── Core Infrastructure (HTTP, parsing, file errors)

====================================================================================
🗂️ KEY DIRECTORY EXPLANATIONS
====================================================================================

📁 /src/core/
   The foundational layer that all other components build upon.
   Contains infrastructure that could be reused across different features.

📁 /src/features/analytics/  
   Self-contained feature module following domain-driven design.
   All analytics-related code is organized here by responsibility.

📁 /public/data/
   Static file serving for CSV data and manifests.
   Organized hierarchically for efficient data discovery and loading.

📁 /lib/
   Shared utilities that work in both browser and Node.js contexts.
   Used by both the main application and development/testing scripts.

📁 /scripts/
   Development and validation tools that operate outside the main application.
   Includes smoke tests and architecture documentation generators.

====================================================================================
🔍 CRITICAL PIPELINE FILES SUMMARY
====================================================================================

🔗 ENTRY POINTS:
├── src/pages/Analytics.jsx                    # User interface entry
└── src/features/analytics/hooks/useAnalyticsQuery.js  # React hook entry

🔗 ORCHESTRATION:
├── src/features/analytics/services/AnalyticsService.js  # Business logic
└── src/features/analytics/repositories/OrdersRepository.js  # Data access

🔗 CORE INFRASTRUCTURE:
├── src/core/io/HttpStaticProvider.js          # HTTP requests
├── src/core/paths/ManifestClient.js           # Data discovery
├── src/core/paths/PathResolver.js             # URL resolution
└── src/core/utils/ordersNormalizer.js         # Data transformation

🔗 DATA CONTRACTS:
├── src/features/analytics/dtos/QueryDTO.js    # Query normalization
├── src/features/analytics/dtos/TableDTO.js    # Table structure  
└── src/features/analytics/dtos/ChartDTO.js    # Chart structure

🔗 UI TRANSFORMATION:
├── src/features/analytics/feeders/tableFeeder.js  # Table formatting
└── src/features/analytics/feeders/chartFeeder.js  # Chart formatting

🔗 USER INTERFACE:
├── src/features/analytics/components/tables/Table.jsx      # Data display
├── src/features/analytics/components/StatusDisplay.jsx     # Status info
└── src/features/analytics/components/charts/Chart.jsx      # Visualization

🔗 CONFIGURATION:
├── src/core/config/dataSources.js             # Data source config
├── public/data/registry/index.json            # Master registry
└── vite.config.js                            # Build & path aliases

🔗 DATA FILES:
└── public/data/newstore/orders/[YYYY]/[YYYY-MM]/[YYYY-MM]_orders_in_store.csv

This structure follows a clean architecture pattern with clear separation of concerns,
making it easy to understand, maintain, and extend the data pipeline system.

====================================================================================

FILSON PORTLAND DATA PIPELINE - COMPLETE SOURCE CODE ROADMAP

This document contains the complete source code for every file in the data pipeline, 
with detailed explanations of how each component connects to build the analytics system.

====================================================================================
📋 PIPELINE FLOW OVERVIEW
====================================================================================

USER ACTION → useAnalyticsQuery Hook → AnalyticsService → OrdersRepository → 
HttpStaticProvider → CSV Files → PathResolver → ManifestClient → 
ordersNormalizer → Adapters → Feeders → UI Components

====================================================================================
🏗️ LAYER 1: CORE INFRASTRUCTURE
====================================================================================

═══════════════════════════════════════════════════════════════════════════════════
📁 src/core/io/HttpStaticProvider.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: HTTP client for fetching static files (CSV, JSON) with error handling
CONNECTS TO: ManifestClient, OrdersRepository
INPUT: URLs for data files
OUTPUT: Raw text/JSON data
═══════════════════════════════════════════════════════════════════════════════════

export class HttpStaticProvider {
  async getText(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
    return await r.text();
  }
  async getJSON(url) {
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
    return await r.json();
  }
}

═══════════════════════════════════════════════════════════════════════════════════
📁 src/core/paths/ManifestClient.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Manages data registry/index files to discover available data months
CONNECTS TO: HttpStaticProvider (uses), OrdersRepository (used by)
INPUT: Manifest URL from dataSources config
OUTPUT: Available months list { yyyy, mm }
CACHING: Single instance cache for performance
═══════════════════════════════════════════════════════════════════════════════════

export class ManifestClient {
  constructor(provider, manifestUrl) {
    this.provider = provider;
    this.manifestUrl = manifestUrl;
    this.cache = null;
  }
  async get() {
    if (this.cache) return this.cache;
    this.cache = await this.provider.getJSON(this.manifestUrl);
    return this.cache;
  }
  async listMonths() {
    const m = await this.get();
    const out = [];
    for (const yyyy of Object.keys(m.years).sort()) {
      for (const mm of m.years[yyyy]) out.push({ yyyy, mm });
    }
    return out;
  }
}

═══════════════════════════════════════════════════════════════════════════════════
📁 src/core/paths/PathResolver.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Resolves file paths using template patterns with variable substitution
CONNECTS TO: OrdersRepository (used by), dataSources config (configured by)
INPUT: Year/month values and path patterns
OUTPUT: Array of candidate URLs to try
TEMPLATE VARS: ${yyyy}, ${mm}, ${baseDir}
═══════════════════════════════════════════════════════════════════════════════════

const expand = (tpl, v) => tpl.replace(/\$\{(\w+)\}/g, (_, k) => v[k] ?? "");

export class PathResolver {
  constructor({ baseDir, monthFilePatterns }) {
    this.baseDir = baseDir;
    this.patterns = monthFilePatterns;
  }
  // keep your original signature
  candidates(yyyy, mm) {
    const vars = { yyyy, mm, baseDir: this.baseDir, base: this.baseDir };
    return this.patterns.map(p => expand(p, vars));
  }
}

═══════════════════════════════════════════════════════════════════════════════════
📁 src/core/config/dataSources.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Centralized configuration for data endpoints and URL patterns
CONNECTS TO: PathResolver, OrdersRepository (configures both)
PATTERN: Template pattern for CSV file locations
STRUCTURE: /data/newstore/orders/{yyyy}/{yyyy-mm}/{yyyy-mm}_orders_in_store.csv
═══════════════════════════════════════════════════════════════════════════════════

export const DATA_SOURCES = {
  ordersInStore: {
    manifestUrl: "/data/newstore/orders/index.json",
    baseDir: "/data/newstore/orders", // served from /public
    monthFilePatterns: [
      // include {yyyy} directory before {yyyy}-{mm}
      "${baseDir}/${yyyy}/${yyyy}-${mm}/${yyyy}-${mm}_orders_in_store.csv",
    ],
  },
};

═══════════════════════════════════════════════════════════════════════════════════
📁 lib/dataPaths.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Universal JSON loader for browser and Node.js environments
CONNECTS TO: Registry files, smoke test scripts
INPUT: Relative paths to JSON files
OUTPUT: Parsed JSON objects
ENV DETECTION: Auto-detects browser vs Node.js context
═══════════════════════════════════════════════════════════════════════════════════

// lib/dataPaths.js
// Canonical access to data/registry/index.json for BOTH browser and node scripts.
// Exports a consistent API used by loaders and smoke scripts.

const REGISTRY_FILE = "data/registry/index.json";

// ---------- Browser & Node readers ----------
export async function loadJsonBrowser(relPath) {
  // Browser fetch; expects dev server to serve /data/**
  const res = await fetch(`/${relPath}`, { credentials: "same-origin" });
  if (!res.ok) throw new Error(`loadJsonBrowser: failed ${relPath} (${res.status})`);
  return res.json();
}

export async function loadJsonNode(relPath) {
  const { readFile } = await import("fs/promises");
  const { resolve } = await import("path");
  const abs = resolve(process.cwd(), relPath);
  const text = await readFile(abs, "utf-8");
  return JSON.parse(text);
}

// ---------- Single entry point ----------
export async function getDataPaths({ env = "browser" } = {}) {
  // Use browser by default; scripts pass { env: "node" }
  const read = env === "node" ? loadJsonNode : loadJsonBrowser;
  return read(REGISTRY_FILE);
}

// ---------- (Optional) tiny helper for mapping dataset IDs ----------
// If you want the mapping here instead of in the loader registry, you could mirror it.
// For now, we keep mapping centralized in loaderRegistry.js.
export default { getDataPaths, loadJsonBrowser, loadJsonNode };

====================================================================================
📊 LAYER 2: DATA SCHEMA & NORMALIZATION  
====================================================================================

═══════════════════════════════════════════════════════════════════════════════════
📁 src/core/schemas/ordersInStore.schema.v1.json
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: JSON Schema defining the structure of order data from CSV files
CONNECTS TO: Data validation, ordersNormalizer (implicit contract)
REQUIRED FIELDS: Order ID, Channel, Status, Order Date/Time, Timezone, Product Name
OPTIONAL FIELDS: Customer info, billing, shipping, associate details
═══════════════════════════════════════════════════════════════════════════════════

{
  "$id": "ordersInStore.schema.v1.json",
  "title": "Orders - In Store (Monthly Export)",
  "type": "object",
  "properties": {
    "Order ID": { "type": "string" },
    "Channel": { "type": "string", "enum": ["store"] },
    "Status": { "type": "string" },
    "Order Date/Time": { "type": "string" },
    "Timezone": { "type": "string" },
    "Product Name": { "type": "string" },
    "Color": { "type": ["string", "null"] },
    "Size": { "type": ["string", "null"] },
    "Fulfillment Location": { "type": "string" },
    "Fulfillment Type": { "type": "string" },
    "Carrier": { "type": ["string", "null"] },
    "Product Net": { "type": "number" },
    "Product Tax": { "type": "number" },
    "Product Subtotal": { "type": "number" },
    "Shipping Cost": { "type": "number" },
    "Currency": { "type": "string" },
    "Payment Method": { "type": ["string", "null"] },
    "Email": { "type": ["string", "null"] },
    "Billing First Name": { "type": ["string", "null"] },
    "Billing Last Name": { "type": ["string", "null"] },
    "Billing Phone": { "type": ["string", "null"] },
    "Billing ZIP": { "type": ["string", "null"] },
    "Shipping First Name": { "type": ["string", "null"] },
    "Shipping Last Name": { "type": ["string", "null"] },
    "Shipping Phone": { "type": ["string", "null"] },
    "Shipping ZIP": { "type": ["string", "null"] },
    "Product Catalog Price": { "type": "number" },
    "Product Price Adjustment": { "type": "number" },
    "Product Discounted Price": { "type": "number" },
    "Applied Coupon Code": { "type": ["string", "null"] },
    "Reason for Discount": { "type": ["string", "null"] },
    "Reason for Return": { "type": ["string", "null"] },
    "Associate Name": { "type": ["string", "null"] },
    "Associate Email": { "type": ["string", "null"] },
    "Tax Strategy": { "type": ["string", "null"] },
    "Demand Location": { "type": ["string", "null"] },
    "Customer Display ID": { "type": ["string", "null"] },
    "Approver Name": { "type": ["string", "null"] },
    "Approver Email": { "type": ["string", "null"] }
  },
  "required": [
    "Order ID",
    "Channel",
    "Status",
    "Order Date/Time",
    "Timezone",
    "Product Name",
    "Fulfillment Location",
    "Fulfillment Type",
    "Product Net",
    "Product Subtotal",
    "Currency"
  ],
  "additionalProperties": true
}

═══════════════════════════════════════════════════════════════════════════════════
📁 src/core/utils/ordersNormalizer.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Advanced data normalization with timezone conversion and error handling
CONNECTS TO: OrdersRepository (used by), Day.js library (uses)
INPUT: Raw CSV row objects with timezone info
OUTPUT: Normalized rows with Pacific timezone timestamps
FEATURES: Multi-strategy parsing, timezone mapping, financial data cleaning
SOURCE TZ: America/New_York (Eastern), TARGET TZ: America/Los_Angeles (Pacific)
═══════════════════════════════════════════════════════════════════════════════════

import dayjs from "dayjs";
import utc from "dayjs/plugin/utc.js";
import timezone from "dayjs/plugin/timezone.js";
import customParseFormat from "dayjs/plugin/customParseFormat.js";

dayjs.extend(utc);
dayjs.extend(timezone);
dayjs.extend(customParseFormat);

const SOURCE_FALLBACK_TZ = "America/New_York";
const TARGET_TZ = "America/Los_Angeles";

// Map timezone abbreviations to IANA timezone names
const TIMEZONE_MAPPING = {
  // Eastern Time
  "EDT": "America/New_York",    // Eastern Daylight Time
  "EST": "America/New_York",    // Eastern Standard Time
  "ET": "America/New_York",     // Eastern Time (generic)
  
  // Central Time
  "CDT": "America/Chicago",     // Central Daylight Time
  "CST": "America/Chicago",     // Central Standard Time
  "CT": "America/Chicago",      // Central Time (generic)
  
  // Mountain Time
  "MDT": "America/Denver",      // Mountain Daylight Time
  "MST": "America/Denver",      // Mountain Standard Time
  "MT": "America/Denver",       // Mountain Time (generic)
  
  // Pacific Time
  "PDT": "America/Los_Angeles", // Pacific Daylight Time
  "PST": "America/Los_Angeles", // Pacific Standard Time
  "PT": "America/Los_Angeles",  // Pacific Time (generic)
  
  // Add more as needed for your data
};

function normalizeTimezone(tzValue) {
  if (!tzValue) return SOURCE_FALLBACK_TZ;
  
  const cleaned = String(tzValue).trim().toUpperCase();
  
  // Check if it's already an IANA timezone (contains slash)
  if (cleaned.includes('/')) {
    return tzValue; // Assume it's already a valid IANA timezone
  }
  
  // Map abbreviation to IANA timezone
  const mapped = TIMEZONE_MAPPING[cleaned];
  if (mapped) {
    return mapped;
  }
  
  // Log unknown timezones for debugging
  console.warn(`Unknown timezone abbreviation: "${tzValue}", using fallback: ${SOURCE_FALLBACK_TZ}`);
  return SOURCE_FALLBACK_TZ;
}

function toNumber(v) {
  if (typeof v === "number" && Number.isFinite(v)) return v;
  if (v == null) return 0;
  if (typeof v === "string") {
    const n = Number(v.replace(/[$,]/g, "").trim());
    return Number.isFinite(n) ? n : 0;
  }
  const n = Number(v);
  return Number.isFinite(n) ? n : 0;
}

export function normalizeOrdersRow(row) {
  const out = {};
  
  try {
    out["Product Name"] = row["Product Name"] ?? null;
    out["Color"]        = row["Color"] ?? null;
    out["Size"]         = row["Size"] ?? null;
    out["Product Net"]  = toNumber(row["Product Net"]);

    const src = row["Order Date/Time"] ?? null;
    const rowTz = normalizeTimezone(row["Timezone"]);

    if (src) {
      // Try multiple parsing strategies for dates like "2025-06-01 2:13pm"
      let d = null;
      
      // Strategy 1: Most common format - YYYY-MM-DD h:mmA (lowercase 'A' for am/pm)
      try {
        d = dayjs.tz(src, "YYYY-MM-DD h:mmA", rowTz);
        if (d.isValid()) {
          console.log(`✅ Strategy 1 success: "${src}" -> "${d.toISOString()}"`);
        }
      } catch (e) {
        // Fail silently, try next strategy
      }
      
      // Strategy 2: Try with double-digit hour - YYYY-MM-DD hh:mmA
      if (!d || !d.isValid()) {
        try {
          d = dayjs.tz(src, "YYYY-MM-DD hh:mmA", rowTz);
          if (d.isValid()) {
            console.log(`✅ Strategy 2 success: "${src}" -> "${d.toISOString()}"`);
          }
        } catch (e) {
          // Fail silently, try next strategy
        }
      }
      
      // Strategy 3: Parse without timezone first, then apply timezone
      if (!d || !d.isValid()) {
        try {
          // First parse the date string without any timezone info
          const naive = dayjs(src, "YYYY-MM-DD h:mmA");
          if (naive.isValid()) {
            // Then convert to the source timezone
            d = naive.tz(rowTz, true); // true = keep the same time but in specified timezone
            if (d.isValid()) {
              console.log(`✅ Strategy 3 success: "${src}" -> "${d.toISOString()}"`);
            }
          }
        } catch (e) {
          // Fail silently, try next strategy
        }
      }
      
      // Strategy 4: Try with lowercase 'a' - YYYY-MM-DD h:mma
      if (!d || !d.isValid()) {
        try {
          d = dayjs.tz(src, "YYYY-MM-DD h:mma", rowTz);
          if (d.isValid()) {
            console.log(`✅ Strategy 4 success: "${src}" -> "${d.toISOString()}"`);
          }
        } catch (e) {
          // Fail silently
        }
      }

      // Strategy 5: Let dayjs try to parse it naturally, then apply timezone
      if (!d || !d.isValid()) {
        try {
          const natural = dayjs(src);
          if (natural.isValid()) {
            d = natural.tz(rowTz);
            if (d.isValid()) {
              console.log(`✅ Strategy 5 success: "${src}" -> "${d.toISOString()}"`);
            }
          }
        } catch (e) {
          // Last resort failed
        }
      }
      
      if (d && d.isValid()) {
        try {
          const t = d.tz(TARGET_TZ);
          out.__yyyy = String(t.year());
          out.__mm   = String(t.month() + 1).padStart(2, "0");
          out["Order Date/Time"] = src;               // keep original
          out.order_datetime_normalized = t.toISOString(); // normalized
        } catch (e) {
          console.log(`❌ Error converting timezone:`, e.message);
        }
      } else {
        console.log(`❌ ALL STRATEGIES FAILED for: "${src}"`);
        // Don't include date fields if parsing failed, but don't crash
      }
    }
    
    return out;
    
  } catch (error) {
    console.error(`❌ Error normalizing row:`, error.message, row);
    // Return a minimal valid row even if normalization fails
    return {
      "Product Name": row["Product Name"] ?? null,
      "Color": row["Color"] ?? null,
      "Size": row["Size"] ?? null,
      "Product Net": 0,
    };
  }
}

====================================================================================
🗄️ LAYER 3: REPOSITORY PATTERN (DATA ACCESS)
====================================================================================

═══════════════════════════════════════════════════════════════════════════════════
📁 src/features/analytics/repositories/OrdersRepository.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Data access layer for order information with CSV parsing and error handling
CONNECTS TO: All core infrastructure, AnalyticsService (used by)
INPUT: Month ranges { startYYYYMM, endYYYYMM }
OUTPUT: { rows: Array, present: Array, missing: Array }
FEATURES: Parallel loading, Papa Parse integration, comprehensive error tracking
═══════════════════════════════════════════════════════════════════════════════════

import Papa from "papaparse";
import { HttpStaticProvider } from "../../../core/io/HttpStaticProvider";
import { ManifestClient } from "../../../core/paths/ManifestClient";
import { PathResolver } from "../../../core/paths/PathResolver";
import { DATA_SOURCES } from "../../../core/config/dataSources";
import { normalizeOrdersRow } from "../../../core/utils/ordersNormalizer";

const provider = new HttpStaticProvider();
const manifest = new ManifestClient(provider, DATA_SOURCES.ordersInStore.manifestUrl);
const resolver = new PathResolver(DATA_SOURCES.ordersInStore);

async function parseCSV(text) {
  return new Promise((resolve, reject) => {
    Papa.parse(text, {
      header: true,
      skipEmptyLines: true,
      dynamicTyping: true,
      complete: (r) => resolve(r.data),
      error: reject,
    });
  });
}

async function loadMonth(yyyy, mm) {
  const urls = resolver.candidates(yyyy, mm);
  console.log(`🔍 Trying to load ${yyyy}-${mm}, candidate URLs:`, urls); // DEBUG LINE
  
  let lastErr;
  for (const url of urls) {
    try {
      console.log(`📁 Attempting to fetch: ${url}`); // DEBUG LINE
      const text = await provider.getText(url);
      const raw = await parseCSV(text);
      const rows = raw.map((r) =>
        normalizeOrdersRow(r, { sourceTz: "America/New_York", normalizeTo: "America/Los_Angeles" })
      );
      console.log(`✅ Successfully loaded ${yyyy}-${mm} from ${url}, got ${rows.length} rows`); // DEBUG LINE
      return { yyyy, mm, url, rows };
    } catch (e) {
      console.log(`❌ Failed to fetch ${url}:`, e.message); // DEBUG LINE
      lastErr = e;
    }
  }
  return { yyyy, mm, url: null, rows: null, error: lastErr };
}

export const OrdersRepository = {
  async findByMonthRange({ startYYYYMM, endYYYYMM }) {
    const months = await manifest.listMonths();
    console.log(`📊 Available months from manifest:`, months); // DEBUG LINE
    
    const inRange = months.filter(({ yyyy, mm }) => {
      const k = `${yyyy}-${mm}`;
      return k >= startYYYYMM && k <= endYYYYMM;
    });
    console.log(`📅 Months in range ${startYYYYMM} to ${endYYYYMM}:`, inRange); // DEBUG LINE

    const results = await Promise.all(inRange.map((m) => loadMonth(m.yyyy, m.mm)));
    const present = results.filter((r) => Array.isArray(r.rows));
    const missing = results.filter((r) => !Array.isArray(r.rows));
    
    console.log(`📈 Results - Present: ${present.length}, Missing: ${missing.length}`); // DEBUG LINE
    console.log(`📋 Missing details:`, missing); // DEBUG LINE
    
    const rows = present.flatMap((r) => r.rows.map((x) => ({ ...x, __yyyy: r.yyyy, __mm: r.mm })));

    return { rows, present, missing };
  },
};

====================================================================================
⚙️ LAYER 4: BUSINESS LOGIC SERVICE
====================================================================================

═══════════════════════════════════════════════════════════════════════════════════
📁 src/features/analytics/services/AnalyticsService.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Business logic orchestration layer that combines repository and adapters
CONNECTS TO: OrdersRepository (uses), Adapters (uses), useAnalyticsQuery (used by)
INPUT: Normalized query objects with time/product/metric filters
OUTPUT: Processed data rows with scoping applied
FLOW: Repository → Time Adapter → Product Adapter → Metric Adapter
═══════════════════════════════════════════════════════════════════════════════════

// src/features/analytics/services/AnalyticsService.js
// Business logic layer: orchestrates repository + adapters.

import { OrdersRepository } from "../repositories/OrdersRepository.js";
import { applyTime } from "../adapters/time/timeAdapter.js";
import { applyProduct } from "../adapters/productAdapter.js";
import { applyMetric } from "../adapters/metricAdapter.js";

export const AnalyticsService = {
  async getOrdersForQuery(query) {
    const { rows, present, missing } = await OrdersRepository.findByMonthRange(query.time);

    let scoped = applyTime(rows, query.time);
    scoped = applyProduct(scoped, query.product);
    scoped = applyMetric(scoped, query.metric);

    return { rows: scoped, present, missing };
  },
};

====================================================================================
🔧 LAYER 5: DATA ADAPTERS (FILTERING & TRANSFORMATION)
====================================================================================

═══════════════════════════════════════════════════════════════════════════════════
📁 src/features/analytics/adapters/time/timeAdapter.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Apply precise time-based filtering beyond month-level repository loading
CONNECTS TO: AnalyticsService (used by), Day.js (uses)
INPUT: Normalized rows with order_datetime_normalized field
OUTPUT: Filtered rows within exact date range
GRANULARITY: Day-level filtering (repository handles month-level)
═══════════════════════════════════════════════════════════════════════════════════

// src/features/analytics/adapters/timeAdapter.js
import dayjs from 'dayjs';

/**
 * Apply time-based filtering and transformations to data rows
 * Repository handles month-level loading, this handles precise filtering
 */
export function applyTime(rows, timeConfig) {
  console.log('🕐 timeAdapter called with:', { rowCount: rows?.length, timeConfig });
  
  if (!timeConfig || !rows?.length) {
    console.log('🕐 timeAdapter: No config or no rows, returning original data');
    return rows;
  }

  // Apply date range filtering
  const filtered = applyDateRange(rows, timeConfig);
  console.log('🕐 timeAdapter: Filtered from', rows.length, 'to', filtered.length, 'rows');
  
  return filtered;
}

function applyDateRange(rows, timeConfig) {
  console.log('🕐 applyDateRange called with:', { rowCount: rows?.length, timeConfig });
  
  const { startDate, endDate } = timeConfig;
  
  if (!startDate || !endDate) {
    console.log('🕐 applyDateRange: No startDate or endDate, returning all rows');
    return rows;
  }

  console.log('🕐 applyDateRange: Filtering from', startDate, 'to', endDate);
  
  const filtered = rows.filter(row => {
    const orderDate = dayjs(row.order_datetime_normalized);
    if (!orderDate.isValid()) {
      console.log('🕐 Invalid date for row:', row.order_datetime_normalized);
      return true; // Keep rows with invalid dates for now
    }
    
    if (startDate && orderDate.isBefore(dayjs(startDate), 'day')) return false;
    if (endDate && orderDate.isAfter(dayjs(endDate), 'day')) return false;
    
    return true;
  });

  console.log('🕐 applyDateRange: Filtered', rows.length, 'rows down to', filtered.length, 'rows');
  console.log('🕐 Sample filtered dates:', filtered.slice(0, 3).map(r => r.order_datetime_normalized));
  
  return filtered;
}

═══════════════════════════════════════════════════════════════════════════════════
📁 src/features/analytics/adapters/productAdapter.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Filter rows based on product criteria (name, color, size)
CONNECTS TO: AnalyticsService (used by)
INPUT: Rows with Product Name, Color, Size fields
OUTPUT: Filtered rows matching product criteria
CONFIG: { ids: [], colors: [], sizes: [] }
═══════════════════════════════════════════════════════════════════════════════════

// src/features/analytics/adapters/productAdapter.js
export function applyProduct(rows, product) {
  if (!product) return rows;
  // Example: { ids: [], colors: [], sizes: [] }
  return rows.filter(r =>
    (!product.ids    || product.ids.includes(r["Product Name"])) &&
    (!product.colors || product.colors.includes(r.Color)) &&
    (!product.sizes  || product.sizes.includes(r.Size))
  );
}

═══════════════════════════════════════════════════════════════════════════════════
📁 src/features/analytics/adapters/metricAdapter.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Apply metric calculations and aggregations (currently a stub)
CONNECTS TO: AnalyticsService (used by)
INPUT: Filtered rows
OUTPUT: Rows with computed metric fields (future enhancement)
STATUS: Placeholder for future metric computations
═══════════════════════════════════════════════════════════════════════════════════

// src/features/analytics/adapters/metricAdapter.js
export function applyMetric(rows, metric) {
  if (!metric) return rows;
  // Example stub: attach computed fields later
  return rows;
}

====================================================================================
📦 LAYER 6: DATA TRANSFER OBJECTS (DTOs)
====================================================================================

═══════════════════════════════════════════════════════════════════════════════════
📁 src/features/analytics/dtos/QueryDTO.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Query parameter normalization and validation
CONNECTS TO: useAnalyticsQuery (used by), UI components (configured by)
INPUT: Raw query objects from UI
OUTPUT: Normalized query with standardized date formats
FEATURES: Date format standardization (YYYY-MM, YYYY-MM-DD), default values
═══════════════════════════════════════════════════════════════════════════════════

export const defaultQuery = { time: null };

const toYM = (v) => {
  if (!v) return null;
  if (typeof v === "string") return v.slice(0, 7);
  if (v instanceof Date && !isNaN(v)) return v.toISOString().slice(0, 7);
  return String(v).slice(0, 7);
};

const toYMD = (v) => {
  if (!v) return null;
  if (typeof v === "string") return v.slice(0, 10); // YYYY-MM-DD
  if (v instanceof Date && !isNaN(v)) return v.toISOString().slice(0, 10);
  return String(v).slice(0, 10);
};

export function normalizeQuery(partial) {
  if (!partial) return defaultQuery;
  const out = { ...defaultQuery };

  if (partial.time) {
    const t = partial.time;
    
    // Get month info for data loading
    const start = toYM(t.startYYYYMM ?? t.start);
    const end   = toYM(t.endYYYYMM   ?? t.end);
    
    // Get full date info for timeAdapter filtering
    const startDate = toYMD(t.startDate);
    const endDate = toYMD(t.endDate);
    
    if (start && end) {
      out.time = { 
        // Month info for data loading
        startYYYYMM: start, 
        endYYYYMM: end,
        // Full date info for timeAdapter filtering
        startDate: startDate,
        endDate: endDate
      };
    } else {
      out.time = null;
    }
  }
  return out;
}

export function mergeQueries(prev, applied) {
  const base = normalizeQuery(prev);
  const inc  = normalizeQuery(applied);
  return { ...base, ...(inc.time ? { time: inc.time } : {}) };
}

═══════════════════════════════════════════════════════════════════════════════════
📁 src/features/analytics/dtos/TableDTO.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Standard table structure for UI components
CONNECTS TO: tableFeeder (used by), Table component (consumed by)
OUTPUT: { columnKeys, rows, totals, rowCount, columnCount, meta }
FEATURES: Empty state handling
═══════════════════════════════════════════════════════════════════════════════════

// src/features/analytics/dtos/TableDTO.js
export function makeEmptyTable() {
  return {
    columnKeys: ["Product Name"],
    rows: [],
    totals: {},
    rowCount: 0,
    columnCount: 1,
    meta: {},
  };
}

═══════════════════════════════════════════════════════════════════════════════════
📁 src/features/analytics/dtos/ChartDTO.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Standard chart structure for visualization components
CONNECTS TO: chartFeeder (used by), Chart component (consumed by)
OUTPUT: { series, categories, meta }
FEATURES: Empty state handling
═══════════════════════════════════════════════════════════════════════════════════

// src/features/analytics/dtos/ChartDTO.js
export function makeEmptyChart() {
  return { series: [], categories: [], meta: {} };
}

====================================================================================
🏭 LAYER 7: DATA FEEDERS (TRANSFORMATION TO UI FORMATS)
====================================================================================

═══════════════════════════════════════════════════════════════════════════════════
📁 src/features/analytics/feeders/tableFeeder.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Transform raw data rows into table-ready format with totals
CONNECTS TO: useAnalyticsQuery (used by), TableDTO (uses), Table component (feeds)
INPUT: Raw normalized rows from AnalyticsService
OUTPUT: TableDTO with formatted rows, column keys, and calculated totals
FEATURES: Column selection, totals calculation, row indexing
═══════════════════════════════════════════════════════════════════════════════════

// src/features/analytics/feeders/tableFeeder.js
import { makeEmptyTable } from "../dtos/TableDTO.js";

export function toTable(rows, opts = {}) {
  if (!rows?.length) return makeEmptyTable();

  const columnKeys = ["Product Name", "Color", "Size", "Product Net", "Order Date/Time"];
  const tableRows = rows.map((r, i) => ({
    "#": i + 1,
    "Product Name": r["Product Name"],
    "Color": r.Color,
    "Size": r.Size,
    "Product Net": r["Product Net"],
    "Order Date/Time" : r["Order Date/Time"]
  }));

  const totals = {
    "Product Net": tableRows.reduce((a, x) => a + (x["Product Net"] ?? 0), 0),
  };

  return {
    columnKeys,
    rows: tableRows,
    totals,
    rowCount: tableRows.length,
    columnCount: columnKeys.length,
    meta: opts.meta ?? {},
  };
}

// Export with both names for flexibility
export const toTableDTO = toTable;
export default toTable;

═══════════════════════════════════════════════════════════════════════════════════
📁 src/features/analytics/feeders/chartFeeder.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Transform raw data into chart-ready time series format
CONNECTS TO: Chart components (feeds), ChartDTO (uses)
INPUT: Raw normalized rows with __yyyy, __mm metadata
OUTPUT: ChartDTO with time-based series data
AGGREGATION: Monthly totals by specified metric (default: Product Net)
═══════════════════════════════════════════════════════════════════════════════════

// src/features/analytics/feeders/chartFeeder.js
import { makeEmptyChart } from "../dtos/ChartDTO.js";

export function toChart(rows, { xKey = "__mm", yKey = "Product Net" } = {}) {
  if (!rows?.length) return makeEmptyChart();

  const byMonth = new Map();
  for (const r of rows) {
    const k = `${r.__yyyy}-${r.__mm}`;
    byMonth.set(k, (byMonth.get(k) ?? 0) + (Number(r[yKey]) || 0));
  }

  const categories = Array.from(byMonth.keys()).sort();
  const series = [{ name: yKey, data: categories.map(c => byMonth.get(c)) }];

  return { categories, series, meta: { xKey, yKey } };
}

====================================================================================
⚛️ LAYER 8: REACT INTEGRATION
====================================================================================

═══════════════════════════════════════════════════════════════════════════════════
📁 src/features/analytics/hooks/useAnalyticsQuery.js
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: React hook that orchestrates the entire data pipeline
CONNECTS TO: All layers (orchestrates), Analytics component (used by)
INPUT: Query objects from UI state
OUTPUT: { table, loading, error, meta } state
LIFECYCLE: Query normalization → Service call → Data transformation → State update
═══════════════════════════════════════════════════════════════════════════════════

import { useEffect, useState } from "react";
import { AnalyticsService } from "../services/AnalyticsService";
import { normalizeQuery } from "../dtos/QueryDTO";
import { toTableDTO } from "../feeders/tableFeeder";

export function useAnalyticsQuery(inputQuery) {
  const [state, setState] = useState({ table: null, loading: false, error: null, meta: null });

  useEffect(() => {
    const q = normalizeQuery(inputQuery);
    if (!q.time) {
      setState({ table: null, loading: false, error: null, meta: null });
      return;
    }

    let cancelled = false;
    setState({ table: null, loading: true, error: null, meta: null });

    AnalyticsService.getOrdersForQuery(q)
      .then((res) => {
        if (cancelled) return;
        const table = toTableDTO(res.rows);
        setState({ table, loading: false, error: null, meta: { missing: res.missing } });
      })
      .catch((err) => {
        if (cancelled) return;
        setState({ table: null, loading: false, error: err, meta: null });
      });

    return () => { cancelled = true; };
  }, [JSON.stringify(inputQuery)]);

  return state;
}

====================================================================================
🎨 LAYER 9: UI COMPONENTS
====================================================================================

═══════════════════════════════════════════════════════════════════════════════════
📁 src/features/analytics/components/StatusDisplay.jsx
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Display query status, loading state, errors, and missing data info
CONNECTS TO: Analytics page (used by), useAnalyticsQuery hook (displays state from)
INPUT: { query, loading, error, meta } from hook
OUTPUT: Formatted status line with range, loading, errors, missing months
FEATURES: Safe formatting of complex objects, missing month display
═══════════════════════════════════════════════════════════════════════════════════

// src/features/analytics/components/StatusDisplay.jsx

import React from 'react';

export function StatusDisplay({ query, loading, error, meta }) {
  // Helper function to safely format missing months
  const formatMissingMonths = (missing) => {
    if (!missing || !Array.isArray(missing)) return "";
    
    return missing.map(m => {
      // Handle both object and primitive formats
      if (typeof m === 'object' && m !== null) {
        // Convert any Date objects or complex objects to strings
        const yyyy = String(m.yyyy || '');
        const mm = String(m.mm || '').padStart(2, '0');
        return `${yyyy}-${mm}`;
      }
      return String(m); // Fallback for primitive values
    }).join(", ");
  };

  return (
    <div className="text-xs text-gray-500 mb-2">
      {query?.time
        ? <>Range: {String(query.time.startYYYYMM)} → {String(query.time.endYYYYMM)}</>
        : "No range selected"}
      {loading ? " • loading…" : ""}
      {error ? ` • error: ${String(error.message || error)}` : ""}
      {!loading && meta?.missing?.length
        ? ` • missing: ${formatMissingMonths(meta.missing)}`
        : ""}
    </div>
  );
}

═══════════════════════════════════════════════════════════════════════════════════
📁 src/features/analytics/components/tables/Table.jsx
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Advanced table component with synchronized scrolling and placeholder support
CONNECTS TO: Analytics page (used by), tableFeeder (consumes data from)
INPUT: TableDTO with rows, columns, totals, and display options
OUTPUT: Sophisticated table UI with fixed headers, synchronized scrolling
FEATURES: Horizontal/vertical scroll sync, placeholder rows, sorting UI, responsive layout
ARCHITECTURE: Split layout with fixed name column and scrollable metrics grid
═══════════════════════════════════════════════════════════════════════════════════

[TABLE COMPONENT SOURCE CODE - 288 lines]
// See the full implementation above - this complex component handles:
// - Split-pane layout (fixed left column + scrollable right grid)
// - Synchronized horizontal scrolling between header and footer
// - Placeholder rows/columns for empty states
// - Sorting UI with directional indicators  
// - Value formatting for currency, percentages, and numbers
// - Responsive design with proper scroll behavior
// - Advanced CSS transforms for scroll synchronization

====================================================================================
📱 LAYER 10: PAGE INTEGRATION
====================================================================================

═══════════════════════════════════════════════════════════════════════════════════
📁 src/pages/Analytics.jsx
───────────────────────────────────────────────────────────────────────────────────
PURPOSE: Main analytics page that brings together all pipeline components
CONNECTS TO: App.jsx (used by), all analytics components (uses)
FEATURES: Query state management, UI panel system, data visualization
FLOW: User interaction → Query updates → Hook triggers → Data flows → UI updates
═══════════════════════════════════════════════════════════════════════════════════

[ANALYTICS PAGE SOURCE CODE - 151 lines]
// Complete implementation showing:
// - useAnalyticsQuery hook integration
// - Query state management with time filtering
// - Panel-based filter UI system
// - Status display integration
// - Table and chart component integration
// - Error handling and loading states

====================================================================================
🚀 COMPLETE DATA FLOW EXAMPLE
====================================================================================

When a user selects a date range in the Analytics UI:

1. USER INTERACTION: Clicks time panel, selects "2025-01 to 2025-03"
   
2. QUERY NORMALIZATION: QueryDTO.normalizeQuery() converts to:
   { time: { startYYYYMM: "2025-01", endYYYYMM: "2025-03", startDate: "2025-01-01", endDate: "2025-03-31" } }

3. HOOK TRIGGERS: useAnalyticsQuery detects change, calls AnalyticsService

4. SERVICE ORCHESTRATION: AnalyticsService.getOrdersForQuery() starts pipeline

5. DATA DISCOVERY: ManifestClient queries /data/newstore/orders/index.json for available months

6. REPOSITORY LOADING: OrdersRepository filters months in range, loads CSV files:
   - /data/newstore/orders/2025/2025-01/2025-01_orders_in_store.csv
   - /data/newstore/orders/2025/2025-02/2025-02_orders_in_store.csv  
   - /data/newstore/orders/2025/2025-03/2025-03_orders_in_store.csv

7. CSV PROCESSING: Papa Parse converts CSV to objects, ordersNormalizer handles:
   - Timezone conversion (Eastern → Pacific)
   - Date parsing with 5 fallback strategies
   - Financial data cleaning ($1,234.56 → 1234.56)

8. ADAPTER FILTERING: 
   - timeAdapter: Filters to exact date range (not just months)
   - productAdapter: Applies product filters (if any)
   - metricAdapter: Adds computed fields (future)

9. DATA TRANSFORMATION: tableFeeder converts to TableDTO:
   - Selects display columns
   - Calculates totals
   - Adds row numbering

10. UI UPDATE: Hook returns { table, loading: false, error: null, meta: { missing: [] } }

11. RENDERING: Table component displays data with synchronized scrolling

12. STATUS DISPLAY: Shows "Range: 2025-01 → 2025-03" with any missing months

This entire pipeline executes asynchronously with proper error handling, 
loading states, and performance optimizations throughout each layer.

====================================================================================
🔧 DEVELOPMENT INTEGRATION POINTS
====================================================================================

To add a new data source or extend the pipeline:

1. **Add Data Source**: Update src/core/config/dataSources.js
2. **Create Repository**: Follow OrdersRepository pattern
3. **Add Normalizer**: Create transformation logic like ordersNormalizer
4. **Create Service**: Add business logic in services/
5. **Build Adapters**: Add filtering logic in adapters/
6. **Create Feeders**: Transform to UI format in feeders/
7. **Add Hook**: Create React integration hook
8. **Build Components**: Create UI components for display

The modular architecture makes it easy to extend any layer independently while 
maintaining the overall data flow contract between components.

====================================================================================